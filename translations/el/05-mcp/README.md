<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "6c816d130a1fa47570c11907e72d84ae",
  "translation_date": "2026-01-05T23:26:20+00:00",
  "source_file": "05-mcp/README.md",
  "language_code": "el"
}
-->
# Ενότητα 05: Πρωτόκολλο Πλαισίου Μοντέλου (MCP)

## Περιεχόμενα

- [Τι θα μάθετε](../../../05-mcp)
- [Τι είναι το MCP;](../../../05-mcp)
- [Πώς λειτουργεί το MCP](../../../05-mcp)
- [Η Πρακτική Ενότητα](../../../05-mcp)
- [Εκτέλεση των Παραδειγμάτων](../../../05-mcp)
  - [Προαπαιτούμενα](../../../05-mcp)
- [Γρήγορη Έναρξη](../../../05-mcp)
  - [Ενέργειες Αρχείων (Stdio)](../../../05-mcp)
  - [Πράκτορας Επιβλέπων](../../../05-mcp)
    - [Κατανόηση των Αποτελεσμάτων](../../../05-mcp)
    - [Στρατηγικές Απάντησης](../../../05-mcp)
    - [Εξήγηση Χαρακτηριστικών της Πρακτικής Ενότητας](../../../05-mcp)
- [Βασικές Έννοιες](../../../05-mcp)
- [Συγχαρητήρια!](../../../05-mcp)
  - [Τι Ακολουθεί;](../../../05-mcp)

## Τι θα μάθετε

Έχετε δημιουργήσει συνομιλητική τεχνητή νοημοσύνη, έχετε κατακτήσει τις εντολές, έχετε βασίσει απαντήσεις σε έγγραφα και έχετε κατασκευάσει πράκτορες με εργαλεία. Όμως όλα αυτά τα εργαλεία ήταν προσαρμοσμένα ειδικά για την εφαρμογή σας. Τι θα γινόταν αν μπορούσατε να δώσετε στην τεχνητή νοημοσύνη σας πρόσβαση σε ένα τυποποιημένο οικοσύστημα εργαλείων που οποιοσδήποτε μπορεί να δημιουργήσει και να μοιραστεί; Σε αυτή την ενότητα, θα μάθετε πώς να το κάνετε ακριβώς αυτό με το Πρωτόκολλο Πλαισίου Μοντέλου (MCP) και την πρακτική ενότητα του LangChain4j. Αρχικά παρουσιάζουμε έναν απλό αναγνώστη αρχείων MCP και έπειτα δείχνουμε πώς ενσωματώνεται εύκολα σε προηγμένες ροές εργασίας πρακτικής χρησιμοποιώντας το πρότυπο Πράκτορα Επιβλέποντα.

## Τι είναι το MCP;

Το Πρωτόκολλο Πλαισίου Μοντέλου (MCP) παρέχει ακριβώς αυτό – έναν τυποποιημένο τρόπο για εφαρμογές τεχνητής νοημοσύνης να ανακαλύπτουν και να χρησιμοποιούν εξωτερικά εργαλεία. Αντί να γράφετε προσαρμοσμένες ενσωματώσεις για κάθε πηγή δεδομένων ή υπηρεσία, συνδέεστε σε διακομιστές MCP που εκθέτουν τις δυνατότητές τους με συνεπή μορφή. Ο πράκτορας AI σας μπορεί στη συνέχεια να ανακαλύψει και να χρησιμοποιήσει αυτόματα αυτά τα εργαλεία.

<img src="../../../translated_images/el/mcp-comparison.9129a881ecf10ff5.png" alt="Σύγκριση MCP" width="800"/>

*Πριν το MCP: Πολύπλοκες ενσωματώσεις σημείο προς σημείο. Μετά το MCP: Ένα πρωτόκολλο, ατελείωτες δυνατότητες.*

Το MCP λύνει ένα θεμελιώδες πρόβλημα στην ανάπτυξη AI: κάθε ενσωμάτωση είναι προσαρμοσμένη. Θέλετε πρόσβαση στο GitHub; Κώδικας προσαρμογής. Θέλετε να διαβάσετε αρχεία; Κώδικας προσαρμογής. Θέλετε να κάνετε ερωτήματα σε βάση δεδομένων; Κώδικας προσαρμογής. Και καμία από αυτές τις ενσωματώσεις δεν λειτουργεί με άλλες εφαρμογές AI.

Το MCP το τυποποιεί αυτό. Ένας διακομιστής MCP εκθέτει εργαλεία με σαφείς περιγραφές και σχήματα. Οποιοσδήποτε πελάτης MCP μπορεί να συνδεθεί, να ανακαλύψει διαθέσιμα εργαλεία και να τα χρησιμοποιήσει. Φτιάξτε μια φορά, χρησιμοποιήστε παντού.

<img src="../../../translated_images/el/mcp-architecture.b3156d787a4ceac9.png" alt="Αρχιτεκτονική MCP" width="800"/>

*Αρχιτεκτονική Πρωτοκόλλου Πλαισίου Μοντέλου - τυποποιημένη ανακάλυψη και εκτέλεση εργαλείων*

## Πώς λειτουργεί το MCP

**Αρχιτεκτονική Διακομιστή-Πελάτη**

Το MCP χρησιμοποιεί μοντέλο πελάτη-διακομιστή. Οι διακομιστές παρέχουν εργαλεία – ανάγνωση αρχείων, ερωτήματα βάσεων δεδομένων, κλήσεις API. Οι πελάτες (η εφαρμογή AI σας) συνδέονται στους διακομιστές και χρησιμοποιούν τα εργαλεία τους.

Για χρήση MCP με το LangChain4j, προσθέστε αυτή τη Maven εξάρτηση:

```xml
<dependency>
    <groupId>dev.langchain4j</groupId>
    <artifactId>langchain4j-mcp</artifactId>
    <version>${langchain4j.version}</version>
</dependency>
```

**Ανακάλυψη Εργαλείων**

Όταν ο πελάτης σας συνδέεται με έναν διακομιστή MCP, ρωτάει "Ποια εργαλεία έχεις;" Ο διακομιστής απαντά με λίστα διαθέσιμων εργαλείων, κάθε ένα με περιγραφές και σχήματα παραμέτρων. Ο AI πράκτοράς σας αποφασίζει ποια εργαλεία να χρησιμοποιήσει βάσει των αιτημάτων του χρήστη.

**Μηχανισμοί Μεταφοράς**

Το MCP υποστηρίζει διάφορους μηχανισμούς μεταφοράς. Αυτή η ενότητα παρουσιάζει τον μηχανισμό Stdio για τοπικές διεργασίες:

<img src="../../../translated_images/el/transport-mechanisms.2791ba7ee93cf020.png" alt="Μηχανισμοί Μεταφοράς" width="800"/>

*Μηχανισμοί μεταφοράς MCP: HTTP για απομακρυσμένους διακομιστές, Stdio για τοπικές διεργασίες*

**Stdio** – [StdioTransportDemo.java](../../../05-mcp/src/main/java/com/example/langchain4j/mcp/StdioTransportDemo.java)

Για τοπικές διεργασίες. Η εφαρμογή σας ξεκινά έναν διακομιστή ως υπο-διεργασία και επικοινωνεί μέσω τυπικής εισόδου/εξόδου. Χρήσιμο για πρόσβαση στο σύστημα αρχείων ή εργαλεία γραμμής εντολών.

```java
McpTransport stdioTransport = new StdioMcpTransport.Builder()
    .command(List.of(
        npmCmd, "exec",
        "@modelcontextprotocol/server-filesystem@2025.12.18",
        resourcesDir
    ))
    .logEvents(false)
    .build();
```

> **🤖 Δοκιμάστε με [GitHub Copilot](https://github.com/features/copilot) Chat:** Ανοίξτε το [`StdioTransportDemo.java`](../../../05-mcp/src/main/java/com/example/langchain4j/mcp/StdioTransportDemo.java) και ρωτήστε:
> - "Πώς λειτουργεί η μεταφορά Stdio και πότε πρέπει να τη χρησιμοποιώ αντί για HTTP;"
> - "Πώς διαχειρίζεται το LangChain4j τον κύκλο ζωής των διεργασιών διακομιστή MCP που ξεκινούν;"
> - "Ποιες είναι οι επιπτώσεις ασφαλείας του να δώσω στην AI πρόσβαση στο σύστημα αρχείων;"

## Η Πρακτική Ενότητα

Ενώ το MCP παρέχει τυποποιημένα εργαλεία, η **πρακτική ενότητα** του LangChain4j παρέχει έναν δηλωτικό τρόπο να φτιάξετε πράκτορες που οργανώνουν αυτά τα εργαλεία. Η σχολιασμός `@Agent` και οι `AgenticServices` σας επιτρέπουν να ορίσετε συμπεριφορά πράκτορα μέσω διεπαφών αντί για επιτακτικό κώδικα.

Σε αυτή την ενότητα, θα εξερευνήσετε το πρότυπο **Πράκτορα Επιβλέποντα** — μια εξελιγμένη προσέγγιση πρακτικής τεχνητής νοημοσύνης όπου ένας "επιβλέπων" πράκτορας αποφασίζει δυναμικά ποιοι υπο-πράκτορες θα ενεργοποιηθούν βάσει των αιτημάτων του χρήστη. Θα συνδυάσουμε και τις δύο έννοιες δίνοντας σε έναν από τους υπο-πράκτορες τη δυνατότητα πρόσβασης σε αρχεία μέσω MCP.

Για να χρησιμοποιήσετε την πρακτική ενότητα, προσθέστε αυτή τη Maven εξάρτηση:

```xml
<dependency>
    <groupId>dev.langchain4j</groupId>
    <artifactId>langchain4j-agentic</artifactId>
    <version>${langchain4j.mcp.version}</version>
</dependency>
```

> **⚠️ Πειραματικό:** Η ενότητα `langchain4j-agentic` είναι **πειραματική** και υπόκειται σε αλλαγές. Ο σταθερός τρόπος κατασκευής βοηθών AI παραμένει το `langchain4j-core` με προσαρμοσμένα εργαλεία (Ενότητα 04).

## Εκτέλεση των Παραδειγμάτων

### Προαπαιτούμενα

- Java 21+, Maven 3.9+
- Node.js 16+ και npm (για διακομιστές MCP)
- Ρυθμισμένες μεταβλητές περιβάλλοντος στο αρχείο `.env` (από τον ριζικό φάκελο):
  - `AZURE_OPENAI_ENDPOINT`, `AZURE_OPENAI_API_KEY`, `AZURE_OPENAI_DEPLOYMENT` (όπως στις Ενότητες 01-04)

> **Σημείωση:** Αν δεν έχετε ρυθμίσει ακόμα τις μεταβλητές περιβάλλοντος, δείτε την [Ενότητα 00 - Γρήγορη Έναρξη](../00-quick-start/README.md) για οδηγίες, ή αντιγράψτε το `.env.example` σε `.env` στον ριζικό φάκελο και συμπληρώστε τις τιμές σας.

## Γρήγορη Έναρξη

**Χρησιμοποιώντας VS Code:** Απλά κάντε δεξί κλικ σε οποιοδήποτε demo αρχείο στον Εξερευνητή και επιλέξτε **"Run Java"**, ή χρησιμοποιήστε τις διαμορφώσεις εκκίνησης από τον πίνακα Εκτέλεση και Αποσφαλμάτωση (βεβαιωθείτε ότι έχετε προσθέσει πρώτα το διακριτικό σας στο αρχείο `.env`).

**Χρησιμοποιώντας Maven:** Εναλλακτικά, μπορείτε να τρέξετε από τη γραμμή εντολών με τα παραδείγματα παρακάτω.

### Ενέργειες Αρχείων (Stdio)

Αυτό δείχνει εργαλεία τοπικής υποδιεργασίας.

**✅ Δεν απαιτούνται προαπαιτούμενα** – ο διακομιστής MCP εκκινείται αυτόματα.

**Χρήση των script έναρξης (Συνιστάται):**

Τα script έναρξης φορτώνουν αυτόματα τις μεταβλητές περιβάλλοντος από το αρχείο `.env` στον ριζικό φάκελο:

**Bash:**
```bash
cd 05-mcp
chmod +x start-stdio.sh
./start-stdio.sh
```

**PowerShell:**
```powershell
cd 05-mcp
.\start-stdio.ps1
```

**Χρησιμοποιώντας VS Code:** Κάντε δεξί κλικ στο `StdioTransportDemo.java` και επιλέξτε **"Run Java"** (βεβαιωθείτε ότι το αρχείο `.env` είναι ρυθμισμένο).

Η εφαρμογή ξεκινά αυτόματα έναν MCP διακομιστή συστήματος αρχείων και διαβάζει ένα τοπικό αρχείο. Παρατηρήστε πώς γίνεται η διαχείριση της υποδιεργασίας για εσάς.

**Αναμενόμενη έξοδος:**
```
Assistant response: The file provides an overview of LangChain4j, an open-source Java library
for integrating Large Language Models (LLMs) into Java applications...
```

### Πράκτορας Επιβλέπων

Το πρότυπο **Πράκτορα Επιβλέποντα** είναι μια **ευέλικτη** μορφή πρακτικής AI. Ένας Επιβλέπων χρησιμοποιεί ένα LLM για να αποφασίσει αυτόνομα ποιους πράκτορες θα ενεργοποιήσει βάσει του αιτήματος του χρήστη. Στο επόμενο παράδειγμα, συνδυάζουμε την πρόσβαση σε αρχεία μέσω MCP με έναν πράκτορα LLM για να δημιουργήσουμε μια ροή ανάγνωσης αρχείου → αναφορά επιβλεπόμενης εργασίας.

Στο demo, ο `FileAgent` διαβάζει αρχεία χρησιμοποιώντας εργαλεία συστήματος αρχείων MCP, και ο `ReportAgent` παράγει μια δομημένη αναφορά με εκτελεστικό περίληψη (1 πρόταση), 3 βασικά σημεία και προτάσεις. Ο Επιβλέπων οργανώνει αυτό το ρεύμα αυτόματα:

<img src="../../../translated_images/el/agentic.cf84dcda226374e3.png" alt="Πρακτική Ενότητα" width="800"/>

```
┌─────────────┐      ┌──────────────┐
│  FileAgent  │ ───▶ │ ReportAgent  │
│ (MCP tools) │      │  (pure LLM)  │
└─────────────┘      └──────────────┘
   outputKey:           outputKey:
  'fileContent'         'report'
```

Κάθε πράκτορας αποθηκεύει την έξοδό του στο **Πρακτικό Πλαίσιο** (κοινή μνήμη), επιτρέποντας στους πιο κάτω πράκτορες να έχουν πρόσβαση σε προηγούμενα αποτελέσματα. Αυτό δείχνει πώς τα εργαλεία MCP ενσωματώνονται αρμονικά σε πρακτικές ροές εργασίας — ο Επιβλέπων δεν χρειάζεται να ξέρει *πώς* διαβάζονται τα αρχεία, μόνο ότι ο `FileAgent` μπορεί να το κάνει.

#### Εκτέλεση του Demo

Τα script έναρξης φορτώνουν αυτόματα τις μεταβλητές περιβάλλοντος από το αρχείο `.env` στον ριζικό φάκελο:

**Bash:**
```bash
cd 05-mcp
chmod +x start-supervisor.sh
./start-supervisor.sh
```

**PowerShell:**
```powershell
cd 05-mcp
.\start-supervisor.ps1
```

**Χρησιμοποιώντας VS Code:** Κάντε δεξί κλικ στο `SupervisorAgentDemo.java` και επιλέξτε **"Run Java"** (βεβαιωθείτε ότι το αρχείο `.env` είναι ρυθμισμένο).

#### Πώς Λειτουργεί ο Επιβλέπων

```java
// Βήμα 1: Το FileAgent διαβάζει αρχεία χρησιμοποιώντας εργαλεία MCP
FileAgent fileAgent = AgenticServices.agentBuilder(FileAgent.class)
        .chatModel(model)
        .toolProvider(mcpToolProvider)  // Διαθέτει εργαλεία MCP για λειτουργίες αρχείων
        .build();

// Βήμα 2: Το ReportAgent δημιουργεί δομημένες αναφορές
ReportAgent reportAgent = AgenticServices.agentBuilder(ReportAgent.class)
        .chatModel(model)
        .build();

// Ο Supervisor συντονίζει τη ροή εργασίας από το αρχείο στην αναφορά
SupervisorAgent supervisor = AgenticServices.supervisorBuilder()
        .chatModel(model)
        .subAgents(fileAgent, reportAgent)
        .responseStrategy(SupervisorResponseStrategy.LAST)  // Επιστροφή της τελικής αναφοράς
        .build();

// Ο Supervisor αποφασίζει ποιοι agents θα κληθούν βάσει του αιτήματος
String response = supervisor.invoke("Read the file at /path/file.txt and generate a report");
```

#### Στρατηγικές Απάντησης

Όταν ρυθμίζετε έναν `SupervisorAgent`, προσδιορίζετε πώς πρέπει να διατυπώσει την τελική απάντησή του στον χρήστη αφού οι υπο-πράκτορες ολοκληρώσουν τα καθήκοντά τους. Οι διαθέσιμες στρατηγικές είναι:

| Στρατηγική | Περιγραφή |
|------------|------------|
| **ΤΕΛΕΥΤΑΙΑ** | Ο επιβλέπων επιστρέφει την έξοδο του τελευταίου υπο-πράκτορα ή εργαλείου που κλήθηκε. Αυτό είναι χρήσιμο όταν ο τελευταίος πράκτορας στη ροή εργασίας είναι ειδικά σχεδιασμένος να παραγάγει την ολοκληρωμένη, τελική απάντηση (π.χ. ένας "Πράκτορας Περίληψης" σε αλυσίδα έρευνας). |
| **ΠΕΡΙΛΗΨΗ** | Ο επιβλέπων χρησιμοποιεί το δικό του εσωτερικό Μοντέλο Γλώσσας (LLM) για να συνθέσει μια περίληψη ολόκληρης της αλληλεπίδρασης και όλων των εξόδων των υπο-πρακτόρων, και επιστρέφει αυτή την περίληψη ως τελική απάντηση. Αυτό παρέχει μια καθαρή, συλλογική απάντηση στον χρήστη. |
| **ΑΞΙΟΛΟΓΗΜΕΝΗ** | Το σύστημα χρησιμοποιεί ένα εσωτερικό LLM για να βαθμολογήσει τόσο την ΤΕΛΕΥΤΑΙΑ απάντηση όσο και την ΠΕΡΙΛΗΨΗ της αλληλεπίδρασης σε σχέση με το αρχικό αίτημα του χρήστη, επιστρέφοντας την έξοδο με την υψηλότερη βαθμολογία. |

Δείτε το [SupervisorAgentDemo.java](../../../05-mcp/src/main/java/com/example/langchain4j/mcp/SupervisorAgentDemo.java) για την πλήρη υλοποίηση.

> **🤖 Δοκιμάστε με [GitHub Copilot](https://github.com/features/copilot) Chat:** Ανοίξτε το [`SupervisorAgentDemo.java`](../../../05-mcp/src/main/java/com/example/langchain4j/mcp/SupervisorAgentDemo.java) και ρωτήστε:
> - "Πώς αποφασίζει ο Επιβλέπων ποιους πράκτορες να ενεργοποιήσει;"
> - "Ποια είναι η διαφορά μεταξύ του προτύπου Επιβλέποντα και των ακολουθιακών ροών εργασίας;"
> - "Πώς μπορώ να προσαρμόσω τη συμπεριφορά σχεδιασμού του Επιβλέποντα;"

#### Κατανόηση των Αποτελεσμάτων

Όταν εκτελέσετε το demo, θα δείτε μια δομημένη παρουσίαση του πώς ο Επιβλέπων οργανώνει πολλαπλούς πράκτορες. Να τι σημαίνει κάθε τμήμα:

```
======================================================================
  FILE → REPORT WORKFLOW DEMO
======================================================================

This demo shows a clear 2-step workflow: read a file, then generate a report.
The Supervisor orchestrates the agents automatically based on the request.
```

**Η κεφαλίδα** παρουσιάζει την έννοια της ροής εργασίας: μια εστιασμένη αλυσίδα από την ανάγνωση αρχείου μέχρι τη δημιουργία αναφοράς.

```
--- WORKFLOW ---------------------------------------------------------
  ┌─────────────┐      ┌──────────────┐
  │  FileAgent  │ ───▶ │ ReportAgent  │
  │ (MCP tools) │      │  (pure LLM)  │
  └─────────────┘      └──────────────┘
   outputKey:           outputKey:
   'fileContent'        'report'

--- AVAILABLE AGENTS -------------------------------------------------
  [FILE]   FileAgent   - Reads files via MCP → stores in 'fileContent'
  [REPORT] ReportAgent - Generates structured report → stores in 'report'
```

**Διάγραμμα Ροής Εργασίας** δείχνει τη ροή δεδομένων μεταξύ πρακτόρων. Κάθε πράκτορας έχει συγκεκριμένο ρόλο:
- **FileAgent** διαβάζει αρχεία με εργαλεία MCP και αποθηκεύει το ακατέργαστο περιεχόμενο στο `fileContent`
- **ReportAgent** καταναλώνει αυτό το περιεχόμενο και παράγει μια δομημένη αναφορά στο `report`

```
--- USER REQUEST -----------------------------------------------------
  "Read the file at .../file.txt and generate a report on its contents"
```

**Αίτημα Χρήστη** δείχνει το καθήκον. Ο Επιβλέπων το αναλύει και αποφασίζει να ενεργοποιήσει τους FileAgent → ReportAgent.

```
--- SUPERVISOR ORCHESTRATION -----------------------------------------
  The Supervisor decides which agents to invoke and passes data between them...

  +-- STEP 1: Supervisor chose -> FileAgent (reading file via MCP)
  |
  |   Input: .../file.txt
  |
  |   Result: LangChain4j is an open-source, provider-agnostic Java framework for building LLM...
  +-- [OK] FileAgent (reading file via MCP) completed

  +-- STEP 2: Supervisor chose -> ReportAgent (generating structured report)
  |
  |   Input: LangChain4j is an open-source, provider-agnostic Java framew...
  |
  |   Result: Executive Summary...
  +-- [OK] ReportAgent (generating structured report) completed
```

**Οργάνωση Επιβλέποντα** δείχνει τη ροή με 2 βήματα σε δράση:
1. **FileAgent** διαβάζει το αρχείο μέσω MCP και αποθηκεύει το περιεχόμενο
2. **ReportAgent** λαμβάνει το περιεχόμενο και δημιουργεί μια δομημένη αναφορά

Ο Επιβλέπων έλαβε αυτές τις αποφάσεις **αυτόνομα** βάσει του αιτήματος του χρήστη.

```
--- FINAL RESPONSE ---------------------------------------------------
Executive Summary
...

Key Points
...

Recommendations
...

--- AGENTIC SCOPE (Data Flow) ----------------------------------------
  Each agent stores its output for downstream agents to consume:
  * fileContent: LangChain4j is an open-source, provider-agnostic Java framework...
  * report: Executive Summary...
```

#### Εξήγηση Χαρακτηριστικών της Πρακτικής Ενότητας

Το παράδειγμα παρουσιάζει πολλά προηγμένα χαρακτηριστικά της πρακτικής ενότητας. Ας ρίξουμε μια πιο προσεκτική ματιά στο Πρακτικό Πλαίσιο και στους Ακροατές Πρακτόρων.

**Πρακτικό Πλαίσιο** δείχνει την κοινή μνήμη όπου οι πράκτορες αποθήκευσαν τα αποτελέσματά τους με τη χρήση του `@Agent(outputKey="...")`. Αυτό επιτρέπει:
- Σε μετέπειτα πράκτορες να έχουν πρόσβαση στα αποτελέσματα προηγούμενων πρακτόρων
- Στον Επιβλέποντα να συνθέτει τελική απάντηση
- Σε εσάς να ελέγχετε τι παρήγαγε κάθε πράκτορας

```java
ResultWithAgenticScope<String> result = supervisor.invokeWithAgenticScope(request);
AgenticScope scope = result.agenticScope();
String fileContent = scope.readState("fileContent");  // Πρώτη ύλη δεδομένων αρχείων από το FileAgent
String report = scope.readState("report");            // Δομημένη αναφορά από το ReportAgent
```

**Ακροατές Πρακτόρων** επιτρέπουν την παρακολούθηση και τον αποσφαλματισμό της εκτέλεσης πρακτόρων. Η βήμα προς βήμα έξοδος που βλέπετε στο demo προέρχεται από έναν AgentListener που συνδέεται σε κάθε κλήση πράκτορα:
- **beforeAgentInvocation** – Καλείται όταν ο Επιβλέπων επιλέγει έναν πράκτορα, αφήνοντάς σας να δείτε ποιος πράκτορας επελέγη και γιατί
- **afterAgentInvocation** – Καλείται όταν ένας πράκτορας ολοκληρώνει, δείχνοντας το αποτέλεσμα του
- **inheritedBySubagents** – Όταν είναι αληθές, ο ακροατής παρακολουθεί όλους τους πράκτορες στην ιεραρχία

```java
AgentListener monitor = new AgentListener() {
    private int step = 0;
    
    @Override
    public void beforeAgentInvocation(AgentRequest request) {
        step++;
        System.out.println("  +-- STEP " + step + ": " + request.agentName());
    }
    
    @Override
    public void afterAgentInvocation(AgentResponse response) {
        System.out.println("  +-- [OK] " + response.agentName() + " completed");
    }
    
    @Override
    public boolean inheritedBySubagents() {
        return true; // Διαδώστε σε όλους τους υπο-πράκτορες
    }
};
```

Πέρα από το πρότυπο Επιβλέποντα, το `langchain4j-agentic` παρέχει αρκετά ισχυρά πρότυπα ροής εργασίας και χαρακτηριστικά:

| Πρότυπο | Περιγραφή | Περίπτωση Χρήσης |
|---------|-----------|------------------|
| **Ακολουθιακό** | Εκτέλεση πρακτόρων σε σειρά, έξοδος ρέει στον επόμενο | Αλυσίδες: έρευνα → ανάλυση → αναφορά |
| **Παράλληλο** | Εκτέλεση πρακτόρων ταυτόχρονα | Ανεξάρτητα καθήκοντα: καιρός + νέα + μετοχές |
| **Βρόχος** | Επανάληψη μέχρι να ικανοποιηθεί συνθήκη | Βαθμολόγηση ποιότητας: βελτίωση μέχρι βαθμός ≥ 0.8 |
| **Υπό όρους** | Δρομολόγηση βάσει συνθηκών | Ταξινόμηση → δρομολόγηση σε ειδικό πράκτορα |
| **Άνθρωπος στη διαδικασία** | Προσθήκη ανθρώπινων σταθμών ελέγχου | Ροές εργασίας έγκρισης, έλεγχος περιεχομένου |

## Βασικές Έννοιες

Τώρα που εξερευνήσατε το MCP και την πρακτική ενότητα στην πράξη, ας συνοψίσουμε πότε να χρησιμοποιείτε κάθε προσέγγιση.

**Το MCP** είναι ιδανικό όταν θέλετε να αξιοποιήσετε υπάρχοντα οικοσυστήματα εργαλείων, να δημιουργήσετε εργαλεία που μπορούν να μοιράζονται πολλές εφαρμογές, να ενσωματώσετε υπηρεσίες τρίτων με πρότυπα πρωτόκολλα ή να ανταλλάξετε υλοποιήσεις εργαλείων χωρίς αλλαγή κώδικα.

**Η Πρακτική Ενότητα** λειτουργεί καλύτερα όταν θέλετε δηλωτικούς ορισμούς πρακτόρων με σχολιασμούς `@Agent`, χρειάζεστε ορχήστρωση ροής εργασίας (ακολουθιακή, βρόχος, παράλληλη), προτιμάτε σχεδίαση πρακτόρων βάσει διεπαφής αντί για επιτακτικό κώδικα, ή συνδυάζετε πολλούς πράκτορες που μοιράζονται εξόδους μέσω του `outputKey`.

**Το πρότυπο Πράκτορα Επιβλέποντα** ξεχωρίζει όταν η ροή εργασίας δεν είναι προβλέψιμη εκ των προτέρων και θέλετε το LLM να αποφασίζει, όταν έχετε πολλούς εξειδικευμένους πράκτορες που χρειάζονται δυναμική ορχήστρωση, όταν φτιάχνετε συνομιλητικά συστήματα που δρομολογούνται σε διαφορετικές δυνατότητες ή όταν θέλετε τη πιο ευέλικτη, προσαρμοστική συμπεριφορά πράκτορα.
## Συγχαρητήρια!

Έχετε ολοκληρώσει το μάθημα LangChain4j για Αρχάριους. Έχετε μάθει:

- Πώς να δημιουργείτε συνομιλητική AI με μνήμη (Ενότητα 01)
- Πρότυπα μηχανικής προτροπής για διάφορα έργα (Ενότητα 02)
- Εδραίωση απαντήσεων στα έγγραφα σας με RAG (Ενότητα 03)
- Δημιουργία βασικών πρακτόρων AI (βοηθών) με προσαρμοσμένα εργαλεία (Ενότητα 04)
- Ενσωμάτωση τυποποιημένων εργαλείων με τα LangChain4j MCP και Agentic modules (Ενότητα 05)

### Τι ακολουθεί;

Μετά την ολοκλήρωση των ενοτήτων, εξερευνήστε τον [Οδηγό Δοκιμών](../docs/TESTING.md) για να δείτε έννοιες δοκιμών LangChain4j σε δράση.

**Επίσημοι Πόροι:**
- [Τεκμηρίωση LangChain4j](https://docs.langchain4j.dev/) - Ολοκληρωμένοι οδηγοί και αναφορά API
- [GitHub LangChain4j](https://github.com/langchain4j/langchain4j) - Πηγαίος κώδικας και παραδείγματα
- [Σεμινάρια LangChain4j](https://docs.langchain4j.dev/tutorials/) - Βήμα προς βήμα μαθήματα για διάφορες χρήσεις

Ευχαριστούμε που ολοκληρώσατε αυτό το μάθημα!

---

**Πλοήγηση:** [← Προηγούμενο: Ενότητα 04 - Εργαλεία](../04-tools/README.md) | [Επιστροφή στην Αρχική](../README.md)

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**Αποποίηση Ευθυνών**:  
Αυτό το έγγραφο έχει μεταφραστεί χρησιμοποιώντας την υπηρεσία μετάφρασης με τεχνητή νοημοσύνη [Co-op Translator](https://github.com/Azure/co-op-translator). Ενώ προσπαθούμε για ακρίβεια, παρακαλούμε να γνωρίζετε ότι οι αυτοματοποιημένες μεταφράσεις ενδέχεται να περιέχουν λάθη ή ανακρίβειες. Το αρχικό έγγραφο στην πρωτότυπη γλώσσα του πρέπει να θεωρείται η επίσημη πηγή. Για κρίσιμες πληροφορίες, συνιστάται επαγγελματική μετάφραση από ανθρώπινο μεταφραστή. Δεν φέρουμε ευθύνη για τυχόν παρεξηγήσεις ή λανθασμένες ερμηνείες που προκύπτουν από τη χρήση αυτής της μετάφρασης.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->